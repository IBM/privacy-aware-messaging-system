-- V1 - Initial SQL DB2 Schema for Musketeer
-- Author: Mark Purcell (markpurcell@ie.ibm.com)

SET schema '${schema_name}';


CREATE SEQUENCE USER_SEQ START WITH 1;

-----------------------------------------------------------------------------
--Users - maps to RabbitMQ user name
--
CREATE SEQUENCE USERS_seq;

CREATE TABLE USERS (
    USER_ID            INTEGER NOT NULL,
    USER_NAME          VARCHAR(101) NOT NULL, --same as user name in RabbitMQ
    ORGANISATION       VARCHAR(501) NOT NULL,
    ACTIVE             INTEGER NOT NULL DEFAULT 1 --0 means the user was removed
    --ADDED              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    --UPDATED            TIMESTAMP -- TODO NOT NULL DEFAULT NEXTVAL ('USERS_seq') EACH ROW AS ROW CHANGE TIMESTAMP
);

ALTER TABLE USERS ADD CONSTRAINT USER_PK PRIMARY KEY (USER_ID);
ALTER TABLE USERS ADD CONSTRAINT USER_UK UNIQUE (USER_NAME);

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
--Tasks 
--

CREATE SEQUENCE TASK_SEQ START WITH 1;

CREATE SEQUENCE TASKS_seq;

CREATE TABLE TASKS (
    TASK_ID            INTEGER NOT NULL,
    USER_ID            INTEGER NOT NULL, --Creator of the task
    TASK_NAME          VARCHAR(101) NOT NULL,
    QUEUE              VARCHAR(101),  --Could be NULL if polling
    STATUS             VARCHAR(21) NOT NULL DEFAULT 'CREATED',
    TOPOLOGY           VARCHAR(101),
    DEFINITION         VARCHAR(5000),
    ADDED              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UPDATED            TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
--TODO ORGANIZE BY ROW;

ALTER TABLE TASKS ADD CONSTRAINT TASK_PK PRIMARY KEY (TASK_ID);
ALTER TABLE TASKS ADD CONSTRAINT TASK_UK UNIQUE (TASK_NAME);
ALTER TABLE TASKS ADD CONSTRAINT TASK_STATUS CHECK (STATUS IN ('CREATED', 'STARTED', 'FAILED', 'COMPLETE'));
ALTER TABLE TASKS ADD CONSTRAINT TASK_CREATOR_FK FOREIGN KEY (USER_ID) REFERENCES USERS (USER_ID) ON DELETE CASCADE;

CREATE FUNCTION update_task_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.UPDATED = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_task_timestamp_trigger
BEFORE UPDATE
ON TASKS
FOR EACH ROW
EXECUTE PROCEDURE update_task_timestamp();

--TODO
--ALTER TABLE TASKS ACTIVATE VALUE COMPRESSION;
--ALTER TABLE TASKS ALTER DEFINITION COMPRESS SYSTEM DEFAULT;
--ALTER TABLE TASKS ALTER TOPOLOGY COMPRESS SYSTEM DEFAULT;

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
--Task Participants 
--
CREATE SEQUENCE ASSIGNMENTS_seq;

CREATE TABLE ASSIGNMENTS (
    TASK_ID            INTEGER NOT NULL,
    USER_ID            INTEGER NOT NULL,
    QUEUE              VARCHAR(101) NOT NULL,
    STATUS             VARCHAR(21) NOT NULL DEFAULT 'CREATED',
    ADDED              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UPDATED            TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
--TODO ORGANIZE BY ROW;

ALTER TABLE ASSIGNMENTS ADD CONSTRAINT ASSIGNMENT_PK PRIMARY KEY (TASK_ID, USER_ID);
ALTER TABLE ASSIGNMENTS ADD CONSTRAINT ASSIGNMENT_UK UNIQUE (QUEUE);
ALTER TABLE ASSIGNMENTS ADD CONSTRAINT TASK_FK FOREIGN KEY (TASK_ID) REFERENCES TASKS (TASK_ID) ON DELETE CASCADE;
ALTER TABLE ASSIGNMENTS ADD CONSTRAINT USER_FK FOREIGN KEY (USER_ID) REFERENCES USERS (USER_ID) ON DELETE CASCADE;
ALTER TABLE ASSIGNMENTS ADD CONSTRAINT ASSIGNMENT_STATUS CHECK (STATUS IN ('CREATED', 'STARTED', 'FAILED', 'COMPLETE'));

CREATE FUNCTION update_assignment_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.UPDATED = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_assignment_timestamp_trigger
BEFORE UPDATE
ON TASKS
FOR EACH ROW
EXECUTE PROCEDURE update_assignment_timestamp();

-----------------------------------------------------------------------------
--Models
--

CREATE SEQUENCE MODEL_SEQ START WITH 1;

CREATE SEQUENCE MODELS_seq;

CREATE TABLE MODELS (
    MODEL_ID           INTEGER NOT NULL,
    TASK_ID            INTEGER NOT NULL,
    EXTERNAL_ID        VARCHAR(251) NOT NULL,
    ADDED              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UPDATED            TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
--TODO ORGANIZE BY ROW;

ALTER TABLE MODELS ADD CONSTRAINT MODEL_PK PRIMARY KEY (MODEL_ID);
ALTER TABLE MODELS ADD CONSTRAINT TASK_FK FOREIGN KEY (TASK_ID) REFERENCES TASKS (TASK_ID) ON DELETE CASCADE;

CREATE TABLE MODEL_ACL (
    MODEL_ID           INTEGER NOT NULL,
    USER_ID            INTEGER NOT NULL
);
--TODO ORGANIZE BY ROW;

ALTER TABLE MODEL_ACL ADD CONSTRAINT MODEL_ACL_PK PRIMARY KEY (MODEL_ID, USER_ID);
ALTER TABLE MODEL_ACL ADD CONSTRAINT MODEL_FK FOREIGN KEY (MODEL_ID) REFERENCES MODELS (MODEL_ID) ON DELETE CASCADE;
ALTER TABLE MODEL_ACL ADD CONSTRAINT USER_FK FOREIGN KEY (USER_ID) REFERENCES USERS (USER_ID) ON DELETE CASCADE;

CREATE FUNCTION update_model_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.UPDATED = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_model_timestamp_trigger
BEFORE UPDATE
ON TASKS
FOR EACH ROW
EXECUTE PROCEDURE update_model_timestamp();


COMMIT;


